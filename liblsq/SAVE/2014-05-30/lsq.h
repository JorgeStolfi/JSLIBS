#ifndef lsq_H
#define lsq_H

/* Fits a linear map of {R^nx} to {R^nf} by least squares, given sampling proc. */
/* Last edited on 2014-05-25 20:37:45 by stolfilocal */

#define lsq_H_COPYRIGHT \
  "Copyright © 2006  by the State University of Campinas (UNICAMP)"

#include <bool.h>

typedef void lsq_gen_case_t(int k, int nx, double Xk[], int nf, double Fk[], double *WkP);
  /* The type of a client-implemented procedure that yields one data record for the purpose of 
    least squares fitting.  The data record consists of a set of argument values {Xk}, a
    corresponding set of function values {Fk}, and a relative weight {Wk}.
    
    The parameter {k} is the sequential index of the data record,
    starting from 0. The procedure should store into the argument vector {Xk[0..nx-1]}
    the values of the {nx} independent variables, and into
    {Fk[0..nf-1]} the corresponding values of the {nf} dependent variables. 
    The procedure should also store into {*WkP} the (non-negative) weight {Wk} of the data record. 
    Ony the relative values of the weights are relevant.  Basically, a data record that has
    weight {Wk} counts the same as {N} data records with weight {Wk/N}, for any {N}. */

int lsq_fit
  ( int nt,     /* Number of cases to generate. */
    int nx,     /* Number of independent variables. */
    int nf,     /* Number of dependent variables (functions to fit). */
    lsq_gen_case_t *gen_case,
    double U[], /* (OUT) Fitted linear transformation matrix. */
    bool_t verbose
  );
  /* Finds the linear function {s} from {R^nx} to {R^nf} that best
    approximates some function {f} from {R^nx} to {R^nf}, over a given
    set of sample cases, by weighted least squares.
    
    The procedure calls {gen_case(k,nx,Xk,nf,Fk,&Wk)}, with {k} varying from 
    0 to {nt-1}, to generate the data records {Xk[0..nx-1]} and {Fk[0..nf-1]}
    for each data record {k}, and its relative weight {Wk}. 
    
    !!! To implement: if {Wk} is set to {+INF} by {gen_case}, it means
    that the function {s} should interpolate {Fk} at {Xk}. !!!
    
    !!! Eliminate {nt} parameter and make {gen_case} return TRUE on EOF. !!!
    
    The matrix {U} should have {nx*nf} elements, interpreted as {nx}
    rows and {nf} columns. The approximation is defined as the
    vector-matrix product {s(x) = x U}. Namely, column {k} of {U} is the
    coefficient vector of the linear combination of {x[0..nx-1]} that
    best approximates coordinate {k} of the function {f}, in the sense of minimizing
    the sum of squared errors {Wk*|Xk U[*,k] - Fk[k]|^2} over all data records
    cases {Xk,Fk,Wk}.
    
    Returns the rank {r} of the least-squares system. If {r} is less
    than {nx}, it means that the {Xk} vectors generated by {gen_sel}
    belonged to a proper linear subspace of {R^{nx}}. In that case the
    best-fit map is not unique.
    
    This procedure uses storage proportional to {nx*(nx+nf)},
    independently of the number of cases {nt}. Therefore may be
    preferrable to {lsq_fit_arrays} when the cases are too numerous to
    fit in memory at once. */


/* AUXILIARY PROCEDURES */

void lsq_compute_matrix_and_rhs(int nt, int nx, int nf, lsq_gen_case_t *gen_case, double A[], double B[], bool_t verbose);
  /* Calls {gen_case(k,nx,Xk,nf,Fk,&Wk)} for {k} in {0..nt-1}, and computes from all those values {Xk[0..nx-1]},
    {Fk[0..nf-1}, and {Wk} the moment matrix {A} ({nx} by {nx}) and the right-hand side matrix {B} ({nx} by {nf}). */

int lsq_solve_system(int nx, int nf, double A[], double B[], double U[], bool_t verbose);
  /* Solves the system {A * U = B} for {U}. Returns the apparent rank of {A}. */
 
void lsq_debug_double_vec(int nx, double x[], char *fmt);
void lsq_debug_int_vec(int nx, int x[], char *fmt);
  /* These procedures print {x[0..nx-1]} to {stderr}, each with format {fmt},
    separated by spaces and bracketed by '[' and ']'. */

#endif
