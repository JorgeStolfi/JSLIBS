/* test_lsq --- test program for {lsq.h}  */
/* Last edited on 2024-12-21 10:56:34 by stolfi */

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <math.h>
#include <limits.h>
#include <assert.h>

#include <affirm.h>
#include <bool.h>
#include <jsrandom.h>
#include <jsmath.h>
#include <vec.h>
#include <rn.h>
#include <rmxn.h>
#include <gausol_solve.h>
#include <gausol_print.h>

#include <lsq.h>
#include <lsq_array.h>

/* GENERAL PARAMETERS */

#define N_CASES 100
  /* Number of cases to generate. */

#define MAX_RUNS 100
  /* Max number of trials per test. */

#define MAX_VARS 10
  /* Max number of independent variables (argument coordinates per data point). */

#define MAX_FUNS 10
  /* Max number of dependent variables (function samples per data point). */

/* INTERNAL PROTOTYPES */

int32_t main (int32_t argc, char **argv);

void test_lsq_fit(uint32_t trial, double eps, bool_t verbose);
  /* Tests the least-squares fitter with noise magnitude {eps}. */

void test_lsq_throw_linear_fn(uint32_t nx, uint32_t nf, double M[]);
  /* Generates a random {nx × nf} linear transformation matrix {M}. */

void test_lsq_throw_data_point(uint32_t nx, uint32_t nf, double M[], double eps, double v[], double f[]);
  /* Generates a case number from some sample set,
    with {nx} independent variables (which are returned in {v[0..nx-1]})
    and {nf} dependent variables (which are returned in {f[0..nx-1]}).
    
    The independent variables will be a random point in the unit ball 
    of {R^nx}. 
    
    The dependent variables are generated by computing the
    vector-matrix product {f = v M}, and adding to each {f[i]} a
    random perturbation uniformly distributed in {[-eps _ +eps]}. */

/* CHECKING LSQ FITTING */

void test_lsq_check_fit(uint32_t nx, uint32_t nf, double M[], double eps, double U[]);
  /* Checks whether the solution {U[]} matches {M}, assuming that the 
    data vectors were perturbed by {±eps}. */

/* IMPLEMENTATIONS */

int32_t main (int32_t argc, char **argv)
  { for (uint32_t i = 0; i < MAX_RUNS; i++) 
      { double eps = pow(0.1, 2*(i % 5) + 3);
        test_lsq_fit(i, eps, i < 5);
      }
    fclose(stderr);
    fclose(stdout);
    return (0);
  }

void test_lsq_fit(uint32_t trial, double eps, bool_t verbose)
  { 
    srand(1665 + 2*trial);
    srandom(1665 + 2*trial);
    uint32_t nx = uint32_abrandom(1, MAX_VARS); /* Number of independent variables (argument coords per data point). */
    uint32_t nf = uint32_abrandom(1, MAX_FUNS); /* Number of dependent variables (function samples per data point). */
    uint32_t nt = (uint32_t)imax(10000, 2*nx + 10);    /* Number of data points. */
    
    fprintf(stderr, "\n");
    fprintf(stderr, "======================================================================\n");
    fprintf(stderr, "%s (%d)\n", __FUNCTION__, trial);
    fprintf(stderr, "testing with nt = %d  nx = %d  nf = %d  eps = %g ...\n", nt, nx, nf, eps);
    
    double *M = rmxn_alloc(nx, nf); /* Correct matrix. */
    
    if (verbose) { fprintf(stderr, "  generating true solution...\n\n"); }
    test_lsq_throw_linear_fn(nx, nf, M);
    if (verbose) { gausol_print_array(stderr, 4, "%12.6f", "true solution matrix:", nx,NULL,0, nf,NULL,0, "M", M, ""); }
    
    /* Data arrays for {lsq_array_fit}: */
    double *X = rmxn_alloc(nt, nx);
    double *F = rmxn_alloc(nt, nf);
    double *W = rn_alloc(nt);
    for (uint32_t k = 0; k < nt; k++)
      { double *Xk = &(X[k*nx]);
        double *Fk = &(F[k*nf]);
        test_lsq_throw_data_point(nx, nf, M, eps, Xk, Fk);
        W[k] = drandom();
      }
    
    /* Case generator for {lsq_fit}: */
    auto void gen_data_point(uint32_t k, uint32_t nxg, double Xkg[], uint32_t nfg, double Fkg[], double *WkgP);
    void gen_data_point(uint32_t k, uint32_t nxg, double Xkg[], uint32_t nfg, double Fkg[], double *WkgP)
      { 
        assert(nxg == nx);
        assert(nfg == nf);
        assert((k >= 0) && (k < nt));
        double *Xk = &(X[k*nx]);
        double *Fk = &(F[k*nf]);
        for (uint32_t i = 0; i < nx; i++) { Xkg[i] = Xk[i]; }
        for (uint32_t i = 0; i < nf; i++) { Fkg[i] = Fk[i]; }
        (*WkgP) = W[k];
      }
    
    /* Call procedures in {lsq} and check results: */
    double *U = rmxn_alloc(nx, nf); /* Fitted linear map matrix. */
    uint32_t rank; /* Rank of least squares system. */
    if (verbose) { fprintf(stderr, "  calling {lsq_fit}...\n\n"); }
    rank = lsq_fit(nt, nx, nf, gen_data_point, U, verbose);
    demand(rank == nx, "could not solve the least squares system");
    test_lsq_check_fit(nx, nf, M, eps, U);

    /* Call procedures in {lsq_array} and check results: */
    if (verbose) { fprintf(stderr, "  calling {lsq_array_fit}...\n\n"); }
    rank = lsq_array_fit(nt, nx, nf, X, F, W, U, verbose);
    demand(rank == nx, "could not solve the least squares system");
    test_lsq_check_fit(nx, nf, M, eps, U);

    /* Cleanup: */
    free(M);
    free(U);
    free(X);
    free(F);
    free(W);

    fprintf(stderr, "done.\n");
    fprintf(stderr, "======================================================================\n");
  }

void test_lsq_check_fit(uint32_t nx, uint32_t nf, double M[], double eps, double U[])
  { double tol = 10*eps;
    for (uint32_t iv = 0; iv < nx; iv++)
      { for (uint32_t jf = 0; jf < nf; jf++) 
          { double Mij = M[iv*nf + jf];
            double Uij = U[iv*nf + jf];
            double s = Uij - Mij;
            if (fabs(s) > tol)
              { fprintf
                  ( stderr,
                    "(U - M)[%d,%d] = %24.16e  eps = %24.16e tol = %24.16e\n", 
                    iv, jf, s, eps, tol
                  );
                demand(FALSE, "** fit is not very good");
              }
          }
      }
    fprintf(stderr, "fit is good with tolerance %23.16e\n", tol);
  }

void test_lsq_throw_linear_fn(uint32_t nx, uint32_t nf, double M[])
  {
    /* Generate power-of-ten scale factor: */
    double Mscale = pow(10.0, int32_abrandom(0,2));
    
    /* Generate a random linear map matrix {M}: */
    for (uint32_t iv = 0; iv < nx; iv++)
      { for (uint32_t jf = 0; jf < nf; jf++) 
          { M[iv*nf + jf] = Mscale * (2*drandom() - 1); }
      }
  }

void test_lsq_throw_data_point
  ( uint32_t nx, 
    uint32_t nf, 
    double M[],
    double eps,
    double v[],
    double f[]
  )
  {
    rn_throw_ball(nx, v);
    rmxn_map_row(nx, nf, v, M, f);
    uint32_t jf;
    for (jf = 0; jf < nf; jf++) 
      { f[jf] += eps * (2*drandom() - 1); }
  }
  
