#define PROG_NAME "msm_test_020_refining"
#define PROG_DESC "test of candidate refinement routines"
#define PROG_VERS "1.0"

/* Last edited on 2011-06-06 17:43:29 by stolfi */

#define msm_test_020_refining_C_COPYRIGHT \
  "Copyright © 2006  by the State University of Campinas (UNICAMP)"

/* !!! Add tests of circular pairings */
/* !!! Add subsampling */

#define PROG_HELP \
  PROG_NAME " \\\n" \
  "  -seqLength {SEQ_LENGTH} -den {DEN} \\\n" \
  "  [ -seqCirc {CIRC_X} {CIRC_Y} ] \\\n" \
  "  -mutDev {MUT_DEV} \\\n" \
  "  -delProb {INS_PROB} \\\n" \
  "  [ -mayExpand ] [ -mayShrink ] \\\n" \
  "  [ -delta {DELTA} ] [ -kappa {KAPPA} ] [ -maxUnp {MAXUNP} ] \\\n" \
  "  -nCands {N_CANDS} \\\n" \
  "  [ -repeat {N_TIMES} ] \\\n" \
  "  {OUT_NAME}"

#define PROG_INFO \
  "NAME\n" \
  "  " PROG_NAME " - " PROG_DESC "\n" \
  "\n" \
  "SYNOPSIS\n" \
  "  " PROG_HELP "\n" \
  "\n" \
  "DESCRIPTION\n" \
  "  This program generates {N_CANDS} random candidate pairings" \
  " between two random real sequences with approximately {SEQ_LENGTH}" \
  " samples, and then refines them, {N_TIMES} times.  The" \
  " sequences may be open or circular.\n" \
  "\n" \
  "  The two sequences are generated by making two copies of" \
  " a random sequence, inserting samples" \
  " at random in each copy, and adding independent" \
  " Gaussian noise to each sample.\n" \
  "\n" \
  "OUTPUT FILES\n" \
  "  All output files will have names starting with {OUT_NAME}.\n" \
  "\n" \
  "  All candidates are plotted together as image files" \
  " \"{OUT_NAME}-{XXX}-cd.pgm\" where {XXX} is \"ini\" (before" \
  " refinement) or \"fin\" (after it)." \
  "\n" \
  "  The sample-to-sample distance matrix for the two sequences" \
  " is plotted as file \"{OUT_NAME}-eq.pgm\"." \
  "\n" \
  "  The dynamic programming tableau for each candidate" \
  " and each iteration of the refinement procedure is plotted as image" \
  " file \"{OUTNAME}-{NNNNN}-{T}.pgm\" where {NNNNN} is a" \
  " five-digit candidate number, and {T} is a single-digit" \
  " iteration number.\n" \
  "\n" \
  "OPTIONS\n" \
  "  -seqLength {SEQ_LENGTH}\n" \
  "    This mandatory argument specifies the" \
  " approximate length (number of samples)" \
  " of the two test sequences.\n" \
  "\n" \
  "  -den {DEN}\n" \
  "    This mandatory argument specifies the" \
  " subsampling factor for pairing.  Rung coordinates will be" \
  " implicitly divided by {DEN} to obtain the sample indices.\n" \
  "\n" \
  "  -seqCirc {CIRC_X} {CIRC_Y}\n" \
  "    These optional arguments specify whether" \
  " the sequences are open (finite-length) or  circular" \
  " (inifite and periodic). The X sequence is open" \
  " if {CIRC_X} is \"F\", circular if {CIRC_X} is \"T\".  Ditto" \
  " for {CIRC_Y} and the Y sequence.  The default is" \
  " \"-seqCirc F F\" (both sequences are open).\n" \
  "\n" \
  "  -mutDev {MUT_DEV}\n" \
  "    This mandatory argument specifies the" \
  " standard deviation of the Gaussian noise to be added to each " \
  " sample in each sequnce.\n" \
  "\n" \
  "  -delProb {DEL_PROB}\n" \
  "    This mandatory argument specifies the sample deletion" \
  " or insertion probability used when generating the" \
  " two sequences.\n" \
  "\n" \
  "  -delta {DELTA}\n" \
  "    This optional argument specifies the" \
  " amount of adjustment allowed for the X and Y coordinates of" \
  " internal rungs of each pairing.  The default is 3.\n" \
  "\n" \
  "  -kappa {DELTA}\n" \
  "    This optional argument specifies the" \
  " amount of X and Y extension allowed" \
  " at either end of each pairing.  The default is 6.\n" \
  "\n" \
  "  -maxUnp {MAXUNP}\n" \
  "    This optional argument specifies the" \
  " maximum unpaired datums between any two rungs of each" \
  " pairing.  The default is 6.\n" \
  "\n" \
  "  -mayExpand\n" \
  "    This optional argument specifies that the {R}-range" \
  " of the refined candidates need not be contained in the" \
  " original candidate's {R}-range.  If omitted, the refined" \
  " {R}-range will be a subset of the orginal range.\n" \
  "\n" \
  "\n" \
  "  -mayShrink\n" \
  "    This optional argument specifies that the {R}-range of" \
  " the refined candidates need not contain the original" \
  " candidate's {R}-range.  If omitted, the refiend {R}-range" \
  " will be a superset of the original range.\n" \
  "\n" \
  "  -nCands {N_CANDS}\n" \
  "    This mandatory argument specifies how many candidates" \
  " to generate.\n" \
  "\n" \
  "  -repeat {N_TIMES}\n" \
  "    This optional argument specifies how many times each" \
  " candidate should be refined.  The default is 1.\n" \
  "\n" \
  argparser_help_info_HELP_INFO "\n" \
  "SEE ALSO\n" \
  "  msm_test_120_mapping(1)\n" \
  "\n" \
  "AUTHOR\n" \
  "  This program was created on 21/dec/2006 by J. Stolfi.\n" \
  "WARRANTY\n" \
  argparser_help_info_NO_WARRANTY "\n" \
  "\n" \
  "RIGHTS\n" \
  "  " msm_test_020_refining_C_COPYRIGHT ".\n" \
  "\n" \
  argparser_help_info_STANDARD_RIGHTS  

#define _GNU_SOURCE
#include <stdio.h>
#include <math.h>
#include <assert.h>
#include <string.h>
#include <stdlib.h>

#include <affirm.h>
#include <float_image.h>
#include <float_pnm_image.h>
#include <jspnm_image.h>
#include <jsmath.h>
#include <argparser.h>

#include <msm_basic.h>
#include <msm_seq_desc.h>
#include <msm_rung.h>
#include <msm_pairing.h>
#include <msm_cand.h>
#include <msm_cand_vec.h>
#include <msm_cand_refine.h>
#include <msm_dyn.h>
#include <msm_image.h>
#include <msm_image_tools.h>
#include <msm_double_vec.h>
#include <msm_test_tools.h>

typedef int msm_seq_pos_t;
/* The numerator of a fractional index into in a sequence. 
   The denominator should be specified separately. */

typedef struct msm_options_t 
  { /* Sequence generation parameters: */
    double seqLength;    /* Expected number of positions on each sequence. */
    bool_t seqCirc[2];   /* Circularity of X and Y sequences. */
    double mutDev;       /* Mutation probability. */
    double delProb;      /* Insertion/deletion probability. */
    int den;             /* Subsampling factor (denominator for {msm_seq_pos_t}s). */
    /* Candidate generation parameters: */
    int nCands;          /* Number of candidates to generate. */
    /* Refinement iteration parameter: */
    int repeat;          /* How many times to refine each candidate. */
    /* Refinement parameters: */
    int delta;           /* Half-width of tableau around original pairing. */
    int kappa;           /* Extension of tableau beyond ends of pairing. */
    bool_t mayExpand;    /* Refined {R}-range may expand beyond original {R}-range. */
    bool_t mayShrink;    /* Refined {R}-range may shrink into the original {R}-range. */
    int maxUnp;          /* Maximum unpaired datums allowed between consecutive rungs. */
    /* Output parameters: */
    char *outDir;       /* Output file name prefix (minus extensions). */
  } msm_options_t;
  
int main(int argc, char**argv);

msm_options_t *msm_get_options(int argc, char**argv);
  /* Parses the command line options, packs 
    them into a {msm_options_t} record. */

#define SEQ_LEVEL 3
  /* An arbitrary sequence filtering level. */

void msm_test_seq_make_ancestral
  ( int ns, 
    msm_seq_id_t id, 
    char *name,
    bool_t circ,
    int den, 
    msm_seq_desc_t *seq, 
    double_vec_t *smp
  );
  /* Creates a test sequence with {ns} random real samples and
    circularity {circ}, subsampled by a factor {den}. Returns the
    sequence descriptor in {*seq} and the sample vector in {*smp}
    (which is allocated by the procedure).
    
    The new sequence will have the given {id,name,circ} attributes,
    level {SEQ_LEVEL}, and {npos} equal to the number of subsampling
    points (either {den*ns} or {den*(ns-1)+1}, depending on whether
    the sequence is circular or not. Its indices will therefore range
    in {0..npos-1}. */

void msm_test_seq_make_derived
  ( double_vec_t *smpo, 
    msm_seq_id_t id, 
    char *name,
    bool_t circ,
    int den, 
    double mutDev,
    double delProb,
    msm_seq_desc_t *seqd,
    double_vec_t *smpd,
    msm_rung_vec_t *gv
  );
  /* Creates a test sequence by mutating a given sequence. Assumes
    that the original sequence has samples {smpo.e[0..ns-1]},
    where {ns == smpo.ne}, and circularity {circ}.
    
    The new sequence will have the given {id,name,circ} attributes,
    level {SEQ_LEVEL}, and {npos == den*ns}. Its indices will
    therefore range in {0..den*ns-1}.
    
    Returns the sequence descriptor in {*seq}, and the samples of the
    new sequence in {*smpd} (which is allocated by the procedure).
    
    Also returns in {gv} a list of rungs that connect the original
    subsamples of the ancestral sequence to their copies in the new
    sequence. */

msm_cand_vec_t msm_fake_initial_cands
  ( int nc, 
    msm_seq_desc_t *seqx,
    msm_seq_desc_t *seqy
  );
  /* Generates a list of {nc} candidates for the two {msm_seq_desc_t}s.
    At east one candidate is near the diagonal. */
  
double msm_test_sample_diffsq
  ( double_vec_t *smpx,
    bool_t circx,
    msm_seq_pos_t ix,
    double_vec_t *smpy, 
    bool_t circy,
    msm_seq_pos_t iy,
    int den
  );
  /* Returns the square of the difference between sample {smpx(ix/den)}
    and {smpy(iy/den)}. Uses linear interpolation. If {circx}
    is TRUE, interprets {smpx} as a circular (infinitely periodic) 
    sequence.  Ditto for {circy} and {smpy}.  */

double msm_test_step_score
  ( msm_seq_desc_t *seqx,
    double_vec_t *smpx,
    msm_seq_desc_t *seqy,
    double_vec_t *smpy,
    msm_rung_t g0, 
    msm_rung_t g1,
    int den
  );
  /* Returns a numeric quality score for the step 
    {g0/den-->g1/den}.  Assumes that the two
    sequences are {seqx,seqy} with sample
    vectors {smpx,smpy}.  */

void msm_show_tableau
  ( char *outDir,         /* File name prefix. */
    int ic,                /* Candidate index. */
    int ir,                /* Refinement iteration index. */
    msm_cand_t *cd,        /* Refined candidate. */
    msm_dyn_tableau_t *tb  /* Dynamic programming tableau. */
  );
  /* Writes an image called "{outDir}/{NNNNN}-{R}.ppm" containing a picture
    of the tableau {tb}, with the candidate {cd} drawn on top of it. */ 

int main(int argc, char**argv)
  { 
    msm_options_t *o = msm_get_options(argc, argv);
    int nc = o->nCands;
    
    fprintf(stderr, "generating and writing the ancestral sequence ...\n");
    double_vec_t smpa;
    msm_seq_desc_t seqa;
    bool_t circa = o->seqCirc[0] | o->seqCirc[1];
    msm_seq_id_t ida = 0;
    char *namea = "A";
    msm_test_seq_make_ancestral(o->seqLength, ida, namea, circa, o->den, &seqa, &smpa);
    msm_test_seq_write_and_plot_named(&seqa, o->den, &smpa, "Ancestral", o->outDir, "-org", 10.0);

    fprintf(stderr, "generating and writing the mutated copies ...\n");
    double_vec_t smp[2];
    msm_seq_desc_t seq[2];
    msm_rung_vec_t gvd[2];
    int j;
    for (j = 0; j < 2; j++)
      { msm_seq_id_t seqId = j+1;
        char *seqName = (j == 0 ? "X" : "Y");
        char *title = (j == 0 ? "Derived X" : "Derived Y");
        char *tag = (j == 0 ? "-mux" : "-muy");
        msm_test_seq_make_derived
          ( &smpa, seqId, seqName, o->seqCirc[j], o->den,
            o->mutDev, o->delProb, 
            &(seq[j]), &(smp[j]), &(gvd[j])
          );
        msm_test_seq_write_and_plot_named(&(seq[j]), o->den, &(smp[j]), title, o->outDir, tag, 10.0);
      }
    
    msm_rung_vec_t gv = msm_rung_vec_join(&(gvd[0]), 0, &(gvd[1]), 0);
    
    auto double rung_score(msm_seq_desc_t *ap, msm_seq_desc_t *bp, msm_rung_t g);

    double rung_score(msm_seq_desc_t *ap, msm_seq_desc_t *bp, msm_rung_t g)
      { 
        (void)msm_seq_desc_same_seq(ap, &(seq[0]), TRUE);
        (void)msm_seq_desc_same_seq(bp, &(seq[1]), TRUE);
        return msm_test_sample_diffsq
          ( &(smp[0]), o->seqCirc[0], g.c[0], 
            &(smp[1]), o->seqCirc[1], g.c[1], 
            o->den
          );
      }

    fprintf(stderr, "plotting distance matrix for test seq pair ...\n");
    msm_pairing_t *pr = msm_pairing_from_rung_vec(&gv, FALSE);
    msm_image_seq_seq_score_write_named(&(seq[0]), &(seq[1]), rung_score, pr, o->outDir, "-eq");
    
    fprintf(stderr, "creating initial candidates ...\n");
    msm_cand_vec_t cdvraw = msm_fake_initial_cands(nc, &(seq[0]), &(seq[1]));

    fprintf(stderr, "writing initial candidates ...\n");
    msm_cand_vec_write_named(&cdvraw, o->outDir, "-ini-cd");
    msm_image_cand_vec_write_named(&cdvraw, &(seq[0]), &(seq[1]), o->outDir, "-ini-cd");
      
    auto double step_score(msm_seq_desc_t *xp, msm_seq_desc_t *yp, msm_rung_t g0, msm_rung_t g1);

    double step_score(msm_seq_desc_t *xp, msm_seq_desc_t *yp, msm_rung_t g0, msm_rung_t g1)
      { return msm_test_step_score(xp, &(smp[0]), yp, &(smp[1]), g0, g1, o->den); }

    fprintf(stderr, "refining candidates ...\n");
    msm_dyn_tableau_t tb = msm_dyn_tableau_new(); /* Dynamic programming tableau. */
    msm_cand_vec_t cdvref = msm_cand_vec_new(nc); /* Refined cands will be {cdvref[0..nc-1]}. */
    int ic;
    for (ic = 0; ic < nc; ic++)
      { msm_cand_t cd = cdvraw.e[ic];
        /* Refine candidate {o->repeat} times: */
        int ir;
        for (ir = 0; ir < o->repeat; ir++)
          { msm_cand_t cdref = msm_cand_refine
              ( &cd,
                o->delta, o->kappa, o->mayExpand, o->mayShrink, o->maxUnp,
                &step_score,
                &tb
              );
            /* Display the matrix: */
            msm_show_tableau(o->outDir, ic, ir, &cdref, &tb);
           /* Prepare for next iteration: */
            cd = cdref;
          }
        cdvref.e[ic] = cd;
      }
      
    fprintf(stderr, "writing final candidates ...\n");
    msm_cand_vec_write_named(&cdvref, o->outDir, "-fin-cd");
    msm_image_cand_vec_write_named(&cdvref, &(seq[0]), &(seq[1]), o->outDir, "-fin-cd");

    return 0;
  }

void msm_test_seq_make_ancestral
  ( int ns, 
    msm_seq_id_t id, 
    char *name,
    bool_t circ,
    int den, 
    msm_seq_desc_t *seq, 
    double_vec_t *smp
  )
  { /* Generate a vector of random numbers: */
    *smp = msm_double_vec_throw_normal(ns);
    /* Smooth it a few times: */
    int nsmooth = 2;
    int j;
    for (j = 0; j < nsmooth; j++)
      { msm_double_vec_smooth(smp); 
        msm_double_vec_normalize(smp);
      }
    /* Compute the number of subsampled index points {npos}: */
    int npos = (circ ? den*ns : den*(ns - 1) + 1);
    /* Assemble the sequence descriptor: */
    (*seq) = msm_seq_desc_make(id, name, SEQ_LEVEL, npos, circ);
  }

void msm_test_seq_make_derived
  ( double_vec_t *smpa, 
    msm_seq_id_t id, 
    char *name,
    bool_t circ,
    int den, 
    double mutDev,
    double delProb,
    msm_seq_desc_t *seqd,
    double_vec_t *smpd,
    msm_rung_vec_t *gv
  )
  { msm_rung_vec_t gvr;
    /* Make a mutated copy {smpd} of the sample vector, noting the pairing {gvr}: */
    msm_double_vec_mutate(smpa, circ, mutDev, delProb, smpd, &gvr);
    /* Compute the number of subsampled index points {npos}: */
    int nsd = smpd->ne;
    int nposd = (circ ? den*nsd : den*(nsd - 1) + 1);
    /* Assemble the sequence descriptor: */
    (*seqd) = msm_seq_desc_make(id, name, SEQ_LEVEL, nposd, circ);
    /* Scale all rungs in {gvr} by {den}: */
    int i;
    for (i = 0; i < gvr.ne; i++)
      { msm_rung_t *gvi = &(gvr.e[i]);
        gvi->c[0] *= den;
        gvi->c[1] *= den;
      }
    /* Interpolate those rungs: */
    (*gv) = msm_rung_vec_interpolate(&gvr);
    /* Recycle the temp storage: */
    free(gvr.e);
  }
  
msm_cand_vec_t msm_fake_initial_cands
  ( int nc, 
    msm_seq_desc_t *seqx,
    msm_seq_desc_t *seqy
  )
  { /* Sequence lengths and circularities: */
    int nx = seqx->npos;
    int ny = seqy->npos;
    /* Define the max candidate length {maxlen}: */
    int maxlen = (nx > ny ? nx : ny);
    int minlen = (maxlen + 9)/10;
    /* Generate the candidates: */
    msm_cand_vec_t cdv = msm_cand_vec_throw
      ( nc, seqx, seqy,
        minlen, maxlen,
        /*circProb*/ 0.1, 
        /*unitProb*/ 0.2,
        /*diagProb*/ 0.2,
        /*skipProb*/ 0.1
      );
    return cdv;
  }

double msm_test_sample_diffsq
  ( double_vec_t *smpx,
    bool_t circx,
    msm_seq_pos_t ix,
    double_vec_t *smpy, 
    bool_t circy,
    msm_seq_pos_t iy,
    int den
  )
  { double fx = ((double)ix)/((double)den);
    double fy = ((double)iy)/((double)den);
    double sx = msm_double_vec_interpolate(smpx, fx, circx);
    double sy = msm_double_vec_interpolate(smpy, fy, circy);
    double ds = sx - sy;
    return ds*ds;
  }

double msm_test_step_score
  ( msm_seq_desc_t *seqx,
    double_vec_t *smpx,
    msm_seq_desc_t *seqy,
    double_vec_t *smpy,
    msm_rung_t g0, 
    msm_rung_t g1,
    int den
  )
  { 
    bool_t debug = FALSE;
    
    /* Get the indices into each sequence: */
    int ix0 = g0.c[0], iy0 = g0.c[1];
    int ix1 = g1.c[0], iy1 = g1.c[1];
    /* See which rungs are defined: */
    bool_t und0 = msm_rung_is_none(g0);
    bool_t und1 = msm_rung_is_none(g1);
    /* Compute a measure {Sm} of how much the step deviates from perfection: */
    double Sm;
    int dx, dy;
    if (und0 || und1)
      { dx = dy = 0; Sm = 0; }
    else 
      { dx = ix1 - ix0; 
        dy = iy1 - iy0;
        if ((dx <= 0) || (dy <= 0))
          { fprintf(stderr, " (%d %d) --> (%d %d)", ix0, iy0, ix1, iy1);
            demand (FALSE, "bad step");
          }
        double BRK = 1.0;
        double SKP = 1.0;
        double UNP = 1.0;
        Sm = 
          BRK*((dx != 1) | (dy != 1) ? 1 : 0) + 
          SKP*imin(dx - 1, dy - 1) + 
          UNP*abs(dx - dy);
      }
    /* Compute a measure {Sd} of the difference between the paired samples: */
    double Sd;
    if (und1)
      { Sd = 0; }
    else
      { /* Compute the sample diffs squared {ds0,ds1} at rungs {g0,g1}: */
        double Sd0 = (und0 ? 0 : msm_test_sample_diffsq(smpx, seqx->circ, ix0, smpy, seqy->circ, iy0, den));
        double Sd1 = (und1 ? 0 : msm_test_sample_diffsq(smpx, seqx->circ, ix1, smpy, seqy->circ, iy1, den));
        double DIF = 2500.0;
        Sd = DIF*(Sd0 + Sd1)/2;
      }
    /* The score is a positive bias minus the two parts: */
    double BIAS = 4.0;
    double S = BIAS - (Sm + Sd);
    if (debug)
      { fprintf(stderr, "  step (%4d %4d)", (und0 ? -1 : ix0), (und0 ? -1 : iy0));
        fprintf(stderr, " -- (%4d %4d)", (und1 ? -1 : ix1), (und1 ? -1 : iy1));
        if (! (und0 || und1)) { fprintf(stderr, " step (%4d %4d)", dx, dy); }
        fprintf(stderr, " Sm = %12.5f Sd = %12.5f S = %12.5f\n", Sm, Sd, S);
      }
    return S;
  }

void msm_show_tableau
  ( char *outDir,
    int ic, /* Candidate index. */
    int ir, /* Refinement iteration index. */
    msm_cand_t *cd, /* Refined candidate. */
    msm_dyn_tableau_t *tb  /* Dynamic programming tableau. */
  )
  {
    msm_seq_desc_t *xp = &(cd->seq[0]);
    msm_seq_desc_t *yp = &(cd->seq[1]);
    char *tag = NULL;
    asprintf(&tag, "-%05d-%d", ic, ir);
    demand(! msm_pairing_is_circular(cd->pr), "circular pairings not supposerted yet");
    int ng = msm_pairing_fund_rung_count(cd->pr);
    msm_rung_t gopt = msm_pairing_get_rung(cd->pr, ng-1);
    msm_image_dyn_tableau_write_named(xp->npos, yp->npos, tb, gopt, outDir, tag);
    free(tag);
  }


msm_options_t *msm_get_options(int argc, char**argv)
  { 
    msm_options_t *o = (msm_options_t *)notnull(malloc(sizeof(msm_options_t)), "no mem");
    
    argparser_t *pp = argparser_new(stderr, argc, argv);
    argparser_set_help(pp, PROG_HELP);
    argparser_set_info(pp, PROG_INFO);
    argparser_process_help_info_options(pp);
    
    argparser_get_keyword(pp, "-seqLength");
    o->seqLength = argparser_get_next_int(pp, 1, INT_MAX);
    
    argparser_get_keyword(pp, "-den");
    o->den = argparser_get_next_int(pp, 1, 100);
    
    if (argparser_keyword_present(pp, "-seqCirc"))
      { o->seqCirc[0] = argparser_get_next_bool(pp);
        o->seqCirc[1] = argparser_get_next_bool(pp);
      }
    else
      { o->seqCirc[0] = o->seqCirc[1] = FALSE; }
    
    argparser_get_keyword(pp, "-mutDev");
    o->mutDev = argparser_get_next_double(pp, 0.0, 1.0);
    
    argparser_get_keyword(pp, "-delProb");
    o->delProb = argparser_get_next_double(pp, 0.0, 1.0 - o->mutDev);
    
    if (argparser_keyword_present(pp, "-delta"))
      { o->delta = argparser_get_next_int(pp, 0, INT_MAX); }
    else
      { o->delta = 3; }
    
    if (argparser_keyword_present(pp, "-kappa"))
      { o->kappa = argparser_get_next_int(pp, 0, INT_MAX); }
    else
      { o->kappa = 6; }
    
    o->mayExpand = argparser_keyword_present(pp, "-mayExpand");

    o->mayShrink = argparser_keyword_present(pp, "-mayShrink");
    
    if (argparser_keyword_present(pp, "-maxUnp"))
      { o->maxUnp = argparser_get_next_int(pp, 0, INT_MAX); }
    else
      { o->maxUnp = 6; }
    
    argparser_get_keyword(pp, "-nCands");
    o->nCands = argparser_get_next_int(pp, 0, INT_MAX);
    
    if (argparser_keyword_present(pp, "-repeat"))
      { o->repeat = argparser_get_next_int(pp, 0, INT_MAX); }
    else
      { o->repeat = 1; }
    
    argparser_skip_parsed(pp);
    
    o->outDir = argparser_get_next(pp);

    argparser_finish(pp);
    
    return o;
  }
